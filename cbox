#!/usr/bin/env bash
# cbox: run Claude Code in a Docker sandbox with open network + SSH agent
set -euo pipefail

VERSION="1.1.5"
IMAGE="cbox:latest"
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/cbox"
DOCKERFILE="${CACHE_DIR}/Dockerfile"

# Configurable resource limits
MEMORY_LIMIT="${CBOX_MEMORY:-4g}"
CPU_LIMIT="${CBOX_CPUS:-2}"

# Enable verbose mode if requested
if [[ "${CBOX_VERBOSE:-0}" == "1" ]]; then
  set -x
  echo "cbox: Verbose mode enabled" >&2
fi

# Function to show help
show_help() {
  cat << EOF
cbox - Claude Code Docker sandbox tool v${VERSION}

Usage: cbox [OPTIONS] [DIRECTORY] [-- CLAUDE_ARGS...]

Options:
  -h, --help       Show this help message
  -v, --version    Display version information
  --verbose        Enable verbose debug output
  --shell          Open a shell instead of Claude
  --verify         Verify installation and exit

Environment Variables:
  CBOX_REBUILD=1   Force rebuild Docker image
  CBOX_VERBOSE=1   Enable verbose debug output
  CBOX_MEMORY=4g   Set container memory limit (default: 4g)
  CBOX_CPUS=4      Set container CPU limit (default: 2)

Features:
  • Rust/Cargo support with persistent dependency cache
  • Cargo registry cached in ~/.cache/cbox/cargo-registry
  • Cargo git deps cached in ~/.cache/cbox/cargo-git
  • Cache automatically created and shared across all sessions
  • Significantly speeds up Rust builds after first compilation

Examples:
  cbox                        # Run in current directory
  cbox ~/project              # Run in specific directory  
  cbox -- chat --model opus   # Pass arguments to Claude
  cbox --shell                # Open shell in container
  CBOX_MEMORY=4g cbox         # Run with 4GB memory limit
  CBOX_CPUS=0.5 cbox          # Run with 0.5 CPU limit

For more information, see: https://github.com/bradleydwyer/cbox
EOF
}

# --- Validation Functions ---

# Validate resource limits
validate_resource_limits() {
  # Validate memory limit format
  if ! [[ "$MEMORY_LIMIT" =~ ^[0-9]+[kmgtKMGT]?$ ]]; then
    echo "cbox: Invalid memory limit format: $MEMORY_LIMIT" >&2
    echo "  Use format like: 1g, 512m, 2048k, or plain number (bytes)" >&2
    return 1
  fi
  
  # Validate CPU limit format  
  if ! [[ "$CPU_LIMIT" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
    echo "cbox: Invalid CPU limit format: $CPU_LIMIT" >&2
    echo "  Use format like: 1, 2, 0.5, 1.5" >&2
    return 1
  fi
  
  return 0
}

# Validate resource limits early
if ! validate_resource_limits; then
  exit 1
fi

# Parse command line arguments
SHELL_MODE=0
VERIFY_MODE=0
WORKDIR="$PWD"

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      show_help
      exit 0
      ;;
    -v|--version)
      echo "cbox version ${VERSION}"
      exit 0
      ;;
    --verbose)
      set -x
      echo "cbox: Verbose mode enabled" >&2
      shift
      ;;
    --shell)
      SHELL_MODE=1
      shift
      ;;
    --verify)
      VERIFY_MODE=1
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo "cbox: Unknown option: $1" >&2
      echo "Try 'cbox --help' for more information." >&2
      exit 1
      ;;
    *)
      # This is the directory argument
      WORKDIR="$1"
      shift
      # Check if next arg is "--" for Claude args
      if [[ $# -gt 0 && "$1" == "--" ]]; then
        shift
        break
      fi
      ;;
  esac
done

# Remaining arguments after -- are passed to Claude
CLAUDE_ARGS=("$@")

# --- Path Security Validation Function ---
validate_path_security() {
  local path="$1"
  
  # Check for shell metacharacters that could lead to command injection
  if [[ "$path" == *";"* ]] || [[ "$path" == *"|"* ]] || [[ "$path" == *"&"* ]] || \
     [[ "$path" == *">"* ]] || [[ "$path" == *"<"* ]] || [[ "$path" == *'$('* ]] || \
     [[ "$path" == *'${'* ]] || [[ "$path" == *'`'* ]]; then
    echo "cbox: Security error: Path contains dangerous shell characters" >&2
    echo "  Characters like ; | & > < $ and backticks are not allowed" >&2
    return 1
  fi
  
  # Check for null bytes (common in path traversal attacks)
  # Use od method for reliable null byte detection
  local null_count
  null_count=$(printf '%s' "$path" | od -An -N1000 -tx1 | tr -d ' \n' | grep -o '00' | wc -l 2>/dev/null || echo 0)
  if [[ "$null_count" -gt 0 ]]; then
    echo "cbox: Security error: Path contains null bytes" >&2
    return 1
  fi
  
  # Get canonical path if directory exists
  local canonical_path="$path"
  if [[ -d "$path" ]]; then
    if command -v realpath >/dev/null 2>&1; then
      canonical_path="$(realpath "$path" 2>/dev/null)" || canonical_path="$path"
    else
      canonical_path="$(cd "$path" 2>/dev/null && pwd)" || canonical_path="$path"
    fi
  else
    # For non-existent paths, try to resolve parent directory traversal
    canonical_path="$(realpath -m "$path" 2>/dev/null)" || canonical_path="$path"
  fi
  
  # Block access to system directories (but allow /tmp, /home, /var/tmp)
  # Check both the original path and canonical path to handle symlinks and non-existent dirs
  for check_path in "$path" "$canonical_path"; do
    case "$check_path" in
      /etc|/etc/*)
        echo "cbox: Security error: Access to system directory denied: $check_path" >&2
        return 1
        ;;
      /sys|/sys/*|/proc|/proc/*|/dev|/dev/*|/boot|/boot/*|/root|/root/*)
        echo "cbox: Security error: Access to system directory denied: $check_path" >&2
        return 1
        ;;
      /bin|/bin/*|/sbin|/sbin/*|/lib|/lib/*|/lib64|/lib64/*)
        echo "cbox: Security error: Access to system directory denied: $check_path" >&2
        return 1
        ;;
      /usr/bin|/usr/bin/*|/usr/sbin|/usr/sbin/*|/usr/lib|/usr/lib/*)
        echo "cbox: Security error: Access to system directory denied: $check_path" >&2
        return 1
        ;;
      /var/log|/var/log/*|/var/run|/var/run/*|/var/lock|/var/lock/*)
        echo "cbox: Security error: Access to system directory denied: $check_path" >&2
        return 1
        ;;
      /var/spool|/var/spool/*|/var/mail|/var/mail/*)
        echo "cbox: Security error: Access to system directory denied: $check_path" >&2
        return 1
        ;;
    esac
  done
  
  return 0
}

# --- Path Security Validation ---
# Validate path for security issues BEFORE Docker checks
if [[ "$WORKDIR" != "$PWD" ]]; then
  # User specified a custom directory - validate it
  if ! validate_path_security "$WORKDIR"; then
    exit 1
  fi
fi

# --- sanity checks ---
if ! command -v docker >/dev/null 2>&1; then
  echo "cbox: Docker is required but not found in PATH." >&2
  echo "  Install Docker Desktop: https://docs.docker.com/get-docker/" >&2
  echo "  Verify installation: docker --version" >&2
  exit 1
fi

# Check if Docker daemon is running
if ! docker version >/dev/null 2>&1; then
  echo "cbox: Docker daemon is not running." >&2
  echo "  Start Docker Desktop or run: sudo systemctl start docker" >&2
  echo "  Verify Docker is running: docker version" >&2
  exit 1
fi

# Verify mode - just check installation
if [[ "$VERIFY_MODE" == "1" ]]; then
  echo "✓ cbox v${VERSION} installed successfully" >&2
  echo "✓ Docker is available and running" >&2
  if [[ -n "${SSH_AUTH_SOCK:-}" && -S "${SSH_AUTH_SOCK:-}" ]]; then
    echo "✓ SSH agent is running" >&2
  else
    echo "⚠ SSH agent not running (optional)" >&2
  fi
  if [[ -f "$HOME/.claude.json" ]]; then
    echo "✓ Claude authentication found" >&2
  else
    echo "⚠ Claude authentication not found (run 'claude login' on host)" >&2
  fi
  exit 0
fi

# Check SSH agent for non-shell mode
if [[ "$SHELL_MODE" == "0" ]]; then
  if [[ -z "${SSH_AUTH_SOCK:-}" ]]; then
    echo "cbox: SSH agent not detected." >&2
    echo "  Start SSH agent: eval \$(ssh-agent -s)" >&2
    echo "  Add your key: ssh-add ~/.ssh/id_rsa" >&2
    echo "  Verify loaded: ssh-add -l" >&2
    exit 1
  elif [[ ! -S "${SSH_AUTH_SOCK:-}" ]]; then
    echo "cbox: SSH agent socket not found at: ${SSH_AUTH_SOCK}" >&2
    echo "  The SSH_AUTH_SOCK variable points to a non-existent socket." >&2
    echo "  Try restarting your SSH agent: eval \$(ssh-agent -s)" >&2
    exit 1
  fi
fi

# Validate working directory
if [[ ! -d "$WORKDIR" ]]; then
  echo "cbox: Directory does not exist: $WORKDIR" >&2
  echo "  Please specify a valid directory or use current directory." >&2
  exit 1
fi

# SECURITY FIX: Resolve to absolute path with -- to prevent option injection
WORKDIR="$(cd -- "$WORKDIR" && pwd)" || {
  echo "cbox: Cannot access directory: $WORKDIR" >&2
  exit 1
}

mkdir -p "$CACHE_DIR"

# Create persistent Cargo cache directories
mkdir -p "$CACHE_DIR/cargo-registry"
mkdir -p "$CACHE_DIR/cargo-git"

# --- minimal image with Claude Code CLI ---
if [[ ! -f "$DOCKERFILE" ]]; then
  cat >"$DOCKERFILE" <<'EOF'
FROM node:20-bookworm-slim
RUN apt-get update && apt-get install -y --no-install-recommends \
    git openssh-client ca-certificates tini bash less curl wget procps build-essential \
    pkg-config libssl-dev sudo && \
    rm -rf /var/lib/apt/lists/*
RUN npm i -g @anthropic-ai/claude-code@latest
# Install line counting utilities
RUN apt-get update && apt-get install -y --no-install-recommends cloc && \
    rm -rf /var/lib/apt/lists/*
RUN curl -LO https://github.com/boyter/scc/releases/latest/download/scc_Linux_x86_64.tar.gz && \
    tar -xzf scc_Linux_x86_64.tar.gz && \
    mv scc /usr/local/bin/ && \
    chmod +x /usr/local/bin/scc && \
    rm scc_Linux_x86_64.tar.gz
# Install Rust
ENV RUSTUP_HOME=/opt/rust
ENV CARGO_HOME=/opt/rust
ENV PATH=/opt/rust/bin:$PATH
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --no-modify-path && \
    chmod -R 755 /opt/rust
# Install Hermit globally for all users
RUN curl -fsSL https://github.com/cashapp/hermit/releases/latest/download/install.sh | HERMIT_USER_HOME=/opt/hermit bash && \
    ln -s /opt/hermit/bin/hermit /usr/local/bin/hermit && \
    echo 'export PATH="/opt/hermit/bin:$PATH"' >> /etc/bash.bashrc
# Create an entrypoint script that sets up the user properly
RUN echo '#!/bin/bash\n\
if [ -n "$HOST_UID" ] && [ -n "$HOST_GID" ]; then\n\
  groupadd -g $HOST_GID host 2>/dev/null || true\n\
  useradd -u $HOST_UID -g $HOST_GID -d /home/host -s /bin/bash host 2>/dev/null || true\n\
  chown -R $HOST_UID:$HOST_GID /home/host 2>/dev/null || true\n\
  # Fix Rust/Cargo permissions for the host user\n\
  chown -R $HOST_UID:$HOST_GID /opt/rust 2>/dev/null || true\n\
  # Configure sudo for the host user\n\
  echo "host ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/host\n\
  chmod 440 /etc/sudoers.d/host\n\
  # Initialize Hermit for the host user\n\
  mkdir -p /home/host/bin && ln -sf /opt/hermit/bin/hermit /home/host/bin/hermit 2>/dev/null || true\n\
  exec gosu host "$@"\n\
else\n\
  exec "$@"\n\
fi' > /entrypoint.sh && chmod +x /entrypoint.sh
# Install gosu for proper user switching
RUN apt-get update && apt-get install -y gosu && rm -rf /var/lib/apt/lists/*
# Create home directory
RUN mkdir -p /home/host/.ssh && chmod 755 /home/host
ENV SHELL=/bin/bash
WORKDIR /work
ENTRYPOINT ["/usr/bin/tini", "--", "/entrypoint.sh"]
EOF
fi

# Build image if missing or CBOX_REBUILD=1
if ! docker image inspect "$IMAGE" >/dev/null 2>&1 || [[ "${CBOX_REBUILD:-0}" == "1" ]]; then
  DOCKER_BUILDKIT=1 docker build -t "$IMAGE" -f "$DOCKERFILE" "$CACHE_DIR"
fi

# Ensure .claude directory exists
mkdir -p "$HOME/.claude"

# Check if .claude.json exists (contains auth token)
if [[ ! -f "$HOME/.claude.json" ]]; then
  echo "Warning: No Claude authentication found at ~/.claude.json" >&2
  echo "You'll need to log in when Claude starts." >&2
fi

# Volume mounts (only if sources exist)
vols=(-v "$WORKDIR":/work
      -v "$SSH_AUTH_SOCK":/ssh-agent
      -v "$HOME/.claude":/home/host/.claude)

# Mount Claude config - needs to be writable for auth updates
[[ -f "$HOME/.claude.json" ]] && vols+=(-v "$HOME/.claude.json":/home/host/.claude.json)
[[ -f "$HOME/.gitconfig" ]] && vols+=(-v "$HOME/.gitconfig":/home/host/.gitconfig:ro)
[[ -f "$HOME/.ssh/known_hosts" ]] && vols+=(-v "$HOME/.ssh/known_hosts":/home/host/.ssh/known_hosts:ro)
[[ -f "$HOME/.git-credentials" ]] && vols+=(-v "$HOME/.git-credentials":/home/host/.git-credentials:ro)

# Mount persistent Cargo cache directories to speed up Rust builds
vols+=(-v "$CACHE_DIR/cargo-registry":/opt/rust/registry)
vols+=(-v "$CACHE_DIR/cargo-git":/opt/rust/git)

# Set up command to run
if [[ "$SHELL_MODE" == "1" ]]; then
  # Shell mode - open bash instead of Claude
  CONTAINER_CMD=("/bin/bash")
  echo "cbox: Opening shell in container (type 'exit' to leave)" >&2
else
  # Normal mode - run Claude with args
  CONTAINER_CMD=("claude" "--dangerously-skip-permissions")
  if [[ ${#CLAUDE_ARGS[@]} -gt 0 ]]; then
    CONTAINER_CMD+=("${CLAUDE_ARGS[@]}")
  fi
fi

# SECURITY FIX: Use array for TTY flags to prevent word splitting vulnerabilities
TTY_FLAGS=()
if [ -t 0 ] && [ -t 1 ]; then
  TTY_FLAGS=("-it")
fi

# Show what we're doing in verbose mode
if [[ "${CBOX_VERBOSE:-0}" == "1" ]]; then
  echo "cbox: Running container with command: ${CONTAINER_CMD[*]}" >&2
  echo "cbox: Working directory: $WORKDIR" >&2
  echo "cbox: Volume mounts: ${#vols[@]} volumes" >&2
fi

# SECURITY HARDENING: Add Docker security capabilities and constraints
exec docker run --rm ${TTY_FLAGS:+"${TTY_FLAGS[@]}"} \
  --memory "$MEMORY_LIMIT" \
  --cpus "$CPU_LIMIT" \
  --cap-drop=ALL \
  --cap-add=CHOWN \
  --cap-add=DAC_OVERRIDE \
  --cap-add=FOWNER \
  --cap-add=SETUID \
  --cap-add=SETGID \
  --cap-add=KILL \
  --security-opt=no-new-privileges \
  --tmpfs /tmp:rw,noexec,nosuid,size=512m \
  --tmpfs /run:rw,noexec,nosuid,size=64m \
  --tmpfs /var/tmp:rw,noexec,nosuid,size=64m \
  --tmpfs /home/host/.cache:rw,noexec,nosuid,size=512m \
  --tmpfs /home/host/.npm:rw,noexec,nosuid,size=256m \
  --tmpfs /home/host/bin:rw,noexec,nosuid,size=64m \
  -e HOME=/home/host \
  -e USER=host \
  -e TERM="${TERM:-xterm-256color}" \
  -e SSH_AUTH_SOCK=/ssh-agent \
  -e HOST_UID="$(id -u)" \
  -e HOST_GID="$(id -g)" \
  -w /work \
  "${vols[@]}" \
  "$IMAGE" "${CONTAINER_CMD[@]}"